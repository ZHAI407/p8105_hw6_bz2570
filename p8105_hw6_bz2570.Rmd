---
title: "p8105_hw6_bz2570"
author: "Boran Zhai"
date: "2025-11-23"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(modelr)
library(p8105.datasets)

set.seed(123)
```

## Problem 1

```{r}
homicide_df = 
  read_csv("data/homicide-data.csv") |> 
  janitor::clean_names() |> 
  mutate(
    city_state = str_c(city, ", ", state),
    resolved = as.numeric(disposition == "Closed by arrest"),
    victim_age = as.numeric(victim_age)
  ) |> 
  filter(
    !city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL"),
    victim_race %in% c("White", "Black")
  )
```

**For the city of Baltimore, MD**

```{r}
# Fit a logistic regression and save the output
baltimore_df = 
  homicide_df |> 
  filter(city_state == "Baltimore, MD") |> 
  select(resolved, victim_age, victim_sex, victim_race)

baltimore_fit = 
  baltimore_df |> 
  glm(resolved ~ victim_age + victim_sex + victim_race, data = _, family = binomial())

summary(baltimore_fit)

# Obtain the estimate and CI of adjusted OR for solving homicides comparing male to female (all other variables fixed)
baltimore_results = 
  baltimore_fit |> 
  broom::tidy() |> 
  mutate(
    OR = exp(estimate),
    CI_lower = exp(estimate - 1.96 * std.error),
    CI_upper = exp(estimate + 1.96 * std.error) 
  ) |>
  filter(term == "victim_sexMale") |>   
  select(term, log_OR = estimate, OR, CI_lower, CI_upper)

baltimore_results |> 
  knitr::kable(digits = 3,
               caption = "For solving homicides comparing male victims to female victims")
```

In Baltimore, MD, after controlling for victim age and race, the odds ratio of solving homicides for male victims were `r round(baltimore_results$OR, 3)` times the odds for female victims with 95% confidence interval [`r round(baltimore_results$CI_lower, 3)`,`r round(baltimore_results$CI_upper, 3)`], indicating that homicides with female victims were significantly more likely to be resolved.

**For all cities**

```{r}
# Fit logistic regression and extract adjusted OR and CI for solving homicides comparing male to female
city_or_results = 
  homicide_df |> 
  nest(data = -city_state) |> 
  mutate(
    models = map(data, \(df) glm(resolved ~ victim_age + victim_sex + victim_race, 
                                data = df, family = binomial())),
    results = map(models, broom::tidy)
  ) |> 
  select(-data, -models) |> 
  unnest(results) |> 
  filter(term == "victim_sexMale") |> 
  mutate(
    OR = exp(estimate),
    CI_lower = exp(estimate - 1.96 * std.error),
    CI_upper = exp(estimate + 1.96 * std.error)
  ) |> 
  select(city_state, log_OR = estimate, OR, CI_lower, CI_upper)

city_or_results |>
  knitr::kable(digits = 3,
               caption = "For solving homicides comparing male victims to female victims")
```

```{r}
# Create a plot showing estimated ORs and CIs for each city
city_or_results |> 
  mutate(city_state = fct_reorder(city_state, OR)) |> 
  ggplot(aes(x = city_state, y = OR)) + 
  geom_point() + 
  geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper),
                width = 0.3, color = "blue") + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") + 
  labs(
    title = "Adjusted OR for solving homicides comparing male to female victims for each city",
    x = "City", 
    y = "Estimated Odds Ratio"
  ) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 11),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 8))
```

The plot shows substantial variation in the adjusted odds ratios across cities, ranging from approximately `r round(min(city_or_results$OR), 2)` to `r round(max(city_or_results$OR), 2)`. In all cities, `r sum(city_or_results$OR > 1)` cities had ORs greater than 1, indicating higher odds of resolution for male victims, while `r sum(city_or_results$OR < 1)` cities had ORs less than 1, suggesting higher odds of resolution for female victims. In `r sum(city_or_results$CI_lower > 1 | city_or_results$CI_upper < 1)` cities, the 95% confidence intervals didn't include 1, indicating statistically significant gender disparities in homicide resolution rates.

## Problem 2

```{r}
data("weather_df")
```

```{r}
bootstrap_results = 
  weather_df |> 
  janitor::clean_names() |> 
  modelr::bootstrap(n = 5000) |> 
  mutate(
    models = map(strap, \(df) lm(tmax ~ tmin + prcp, data = df)), 
    results_1 = map(models, broom::glance),
    results_2 = map(models, broom::tidy)
  ) |> 
  select(-strap, -models) |> 
  unnest(results_1) |> 
  select(bootstrap_id = .id, r_squared = r.squared, results_2) |> 
  unnest(results_2) |> 
  filter(term %in% c("tmin", "prcp")) |> 
  select(bootstrap_id, r_squared, term, coefficient = estimate) |> 
  pivot_wider(
    names_from = term,
    values_from = coefficient
  ) |> 
  mutate(beta_ratio = tmin / prcp) |> 
  select(bootstrap_id, r_squared, beta_ratio)

bootstrap_results |> 
  head(5) |> 
  knitr::kable(digits = 3, 
               caption = "Above showing first 5 rows of bootstrap_results")
```

```{r}
# Plot the distributions of estimates
bootstrap_results |> 
  pivot_longer(
    r_squared:beta_ratio,
    names_to = "statistic",
    values_to = "estimate"
  ) |> 
  ggplot(aes(x = estimate)) + 
  geom_density() + 
  facet_wrap(~statistic, scales = "free") + 
  labs(title = "Distributions of estimated R-squared and beta ratio",
       x = "Estimate",
       y = "Density"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 11))
```

Above distributions are derived from 5000 bootstrap samples, reflecting the variability of the estimated beta ratio and R-squared:

The distribution of beta_ratio is unimodal, which begins with a density nearly zero at `r round(min(bootstrap_results$beta_ratio, na.rm = TRUE), 0)`, rises obviously, peaks around `r round(mean(bootstrap_results$beta_ratio, na.rm = TRUE), 0)`, and then decreases until the density approaches zero at `r round(max(bootstrap_results$beta_ratio, na.rm = TRUE), 0)`.

The distribution of r_squared is also unimodal, which starts with a zero density at `r round(min(bootstrap_results$r_squared, na.rm = TRUE), 3)`, increases sharply, peaks around `r round(mean(bootstrap_results$r_squared, na.rm = TRUE), 3)`, and then decreases as it approaches `r round(max(bootstrap_results$r_squared, na.rm = TRUE), 3)`.

```{r}
# Provide 95% confidence interval
bootstrap_ci = 
  bootstrap_results |> 
  summarize(
    r_squared_lower = quantile(r_squared, 0.025),
    r_squared_upper = quantile(r_squared, 0.975),
    beta_ratio_lower = quantile(beta_ratio, 0.025, na.rm = TRUE),
    beta_ratio_upper = quantile(beta_ratio, 0.975, na.rm = TRUE)
  ) 
  
bootstrap_ci |> 
  knitr::kable(digits = 3)
```

Based on 5000 bootstrap samples, the 95% confidence interval for estimated **R-squared** is [`r round(bootstrap_ci$r_squared_lower, 3)`, `r round(bootstrap_ci$r_squared_upper, 3)`]; and the 95% confidence interval for estimated **β1/β2** is [`r round(bootstrap_ci$beta_ratio_lower, 3)`, `r round(bootstrap_ci$beta_ratio_upper, 3)`].

## Problem 3

```{r}
# Load and clean the data
birthweight_df = 
  read_csv("data/birthweight.csv") |> 
  janitor::clean_names() |> 
  mutate(
    babysex = as.factor(babysex),
    frace = as.factor(frace),
    malform = as.factor(malform),
    mrace = as.factor(mrace)
  ) |> 
  drop_na()
```

#### Propose a regression model for birthweight

```{r}
full_model = lm(bwt ~ ., data = birthweight_df)
stepwise_model = step(full_model, direction = "both", trace = 0)

stepwise_model |> 
  broom::tidy() |> 
  knitr::kable(digits = 3, caption = "Stepwise Regression Results for Birthweight")

stepwise_formula = formula(stepwise_model)
```

**Modeling process:** This model based on a data-driven model-building process. Using stepwise regression (both directions) to select the most relevant predictors for birthweight from all available variables.

```{r}
# Plot model residuals against fitted values using add_predictions and add_residuals
birthweight_df |> 
  modelr::add_predictions(stepwise_model) |> 
  modelr::add_residuals(stepwise_model) |> 
  ggplot(aes(x = pred, y = resid)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(se = FALSE, color = "red") +
  labs(
    title = "Residuals against Fitted Values",
    subtitle = "Stepwise Regression Model",
    x = "Fitted Values",
    y = "Residuals"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, face = "bold", size = 12))
```

#### Make comparison in terms of the cross-validated prediction error

```{r}
cv_results = 
  birthweight_df |> 
  crossv_mc(100) |> 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble)
  ) |> 
  mutate(
    # Stepwise model (both)
    stepwise = map(train, \(df) lm(stepwise_formula, data = df)),
    # Linear model only contain main effects (length + gestational age)
    linear = map(train, \(df) lm(bwt ~ blength + gaweeks, data = df)),
    # Interaction model (head circumference, length, sex)
    interaction = map(train, \(df) lm(bwt ~ bhead * blength * babysex, data = df))
  ) |> 
  mutate(
    rmse_stepwise = map2_dbl(stepwise, test, \(mod, df) rmse(model = mod, data = df)),
    rmse_linear = map2_dbl(linear, test, \(mod, df) rmse(model = mod, data = df)),
    rmse_interaction = map2_dbl(interaction, test, \(mod, df) rmse(model = mod, data = df))
  )
```

```{r}
cv_results |> 
  select(starts_with("rmse")) |> 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_"
  ) |> 
  mutate(model = fct_inorder(model)) |> 
  ggplot(aes(x = model, y = rmse)) + 
  geom_violin() +
  labs(
    title = "Cross-validated RMSE Comparison",
    x = "Model",
    y = "RMSE"
  ) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.text.x = element_text(size = 11))
```

```{r}
cv_summary = 
  cv_results |> 
  select(starts_with("rmse")) |> 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_"
  ) |> 
  group_by(model) |> 
  summarize(
    mean_rmse = mean(rmse),
    sd_rmse = sd(rmse),
    n_folds = n()
  ) |> 
  mutate(
    model_name = case_when(
      model == "stepwise" ~ "Stepwise Model",
      model == "linear" ~ "Linear Model", 
      model == "interaction" ~ "Interaction Model"
    )
  ) |> 
  select(model_name, mean_rmse, sd_rmse) |> 
  arrange(mean_rmse)
cv_summary |> 
  knitr::kable(digits = 3)
```

Among the three models, the stepwise regression have the best predictive performance with a cross-validated RMSE of `r round(cv_summary$mean_rmse[1], 3)`.
